#ifndef MP3_STREAM_DECODER_H
#define MP3_STREAM_DECODER_H

#include <vector>
#include <iostream>
#include <stdexcept>
#include <cstring>
#include <deque>

#define DR_MP3_IMPLEMENTATION
#include "../soloud/src/audiosource/wav/dr_mp3.h"

#define DRMP3_MAX_FRAME_SIZE 1441 // Maximum possible frame size for MP3

/// @brief Wrapper class for MP3 stream decoder using dr_mp3
class MP3DecoderWrapper {
private:
    drmp3 decoder;
    drmp3_uint32 targetSampleRate;
    drmp3_uint32 targetChannels;
    bool isInitialized;
    size_t currentFrameSize;
    size_t minRequiredBytes;
    bool isVBR;
    std::deque<size_t> previousFrameSizes;
    bool hasDecodedFrames;  // Track if we've successfully decoded any frames

class MP3DecoderWrapper {
private:
    drmp3 decoder;
    drmp3_uint32 targetSampleRate;
    drmp3_uint32 targetChannels;
    bool isInitialized;
    size_t currentFrameSize;
    size_t minRequiredBytes;
    bool isVBR;
    std::deque<size_t> previousFrameSizes;
    bool hasDecodedFrames;  // Track if we've successfully decoded any frames

    static bool isValidMp3Header(const unsigned char* data, size_t* frameSize = nullptr) {
        if (!data) return false;
        
        if ((data[0] != 0xFF) || ((data[1] & 0xE0) != 0xE0)) return false;

        unsigned char version = (data[1] >> 3) & 0x03;
        unsigned char layer = (data[1] >> 1) & 0x03;
        unsigned char bitrate_idx = (data[2] >> 4) & 0x0F;
        unsigned char samplerate_idx = (data[2] >> 2) & 0x03;
        unsigned char padding = (data[2] >> 1) & 0x01;
        
        if (layer == 0 || bitrate_idx == 0 || bitrate_idx == 0x0F || samplerate_idx == 0x03) {
            return false;
        }

        if (frameSize) {
            static const int bitrates[] = {
                32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320
            };
            static const int samplerates[] = { 44100, 48000, 32000 };
            
            int bitrate = bitrates[bitrate_idx - 1] * 1000;
            int samplerate = samplerates[samplerate_idx];
            if (version == 2 || version == 0) samplerate /= 2;
            
            *frameSize = (144 * bitrate / samplerate) + padding;
        }
        
        return true;
    }

    bool initializeDecoder(const unsigned char* data, size_t dataSize) {
        cleanup();

        if (dataSize < 4) {
            printf("Not enough data for MP3 header (%zu bytes)\n", dataSize);
            return false;
        }

        // Validate header and get frame size
        size_t frameSize;
        if (!isValidMp3Header(data, &frameSize)) {
            printf("Invalid MP3 header\n");
            return false;
        }

        printf("Found valid MP3 header. Frame size: %zu\n", frameSize);

        // Initialize decoder
        if (!drmp3_init_memory(&decoder, data, dataSize, nullptr)) {
            printf("drmp3_init_memory failed\n");
            return false;
        }

        printf("Decoder initialized: sr=%u, ch=%u\n", decoder.sampleRate, decoder.channels);
        
        if (decoder.channels > 2) {
            cleanup();
            printf("Unsupported channel count: %u\n", decoder.channels);
            return false;
        }

        isInitialized = true;
        currentFrameSize = frameSize;
        minRequiredBytes = frameSize;
        return true;
    }

    void updateFrameSizeTracking(size_t newFrameSize) {
        if (newFrameSize == 0) return;

        if (currentFrameSize == 0) {
            currentFrameSize = newFrameSize;
            minRequiredBytes = newFrameSize;
            std::fill(previousFrameSizes.begin(), previousFrameSizes.end(), newFrameSize);
            return;
        }
        
        previousFrameSizes.pop_front();
        previousFrameSizes.push_back(newFrameSize);

        size_t firstSize = previousFrameSizes.front();
        isVBR = false;
        
        for (size_t size : previousFrameSizes) {
            if (size > 0 && size != firstSize) {
                isVBR = true;
                break;
            }
        }

        if (isVBR) {
            size_t maxSize = 0;
            for (size_t size : previousFrameSizes) {
                maxSize = std::max(maxSize, size);
            }
            minRequiredBytes = maxSize;
        } else {
            minRequiredBytes = newFrameSize;
        }
        
        currentFrameSize = newFrameSize;
    }

public:

/// Wrapper class for MP3 stream decoder using dr_mp3
class MP3DecoderWrapper {
private:
    drmp3 decoder;
    drmp3_uint32 targetSampleRate;
    drmp3_uint32 targetChannels;
    bool isInitialized;
    size_t currentFrameSize;
    size_t minRequiredBytes;
    bool isVBR;
    std::deque<size_t> previousFrameSizes;
    bool hasDecodedFrames;  // Track if we've successfully decoded any frames

    bool initializeDecoder(const unsigned char* data, size_t dataSize);
    void updateFrameSizeTracking(size_t newFrameSize);
    static bool isValidMp3Header(const unsigned char* data, size_t* frameSize = nullptr);

public:
    MP3DecoderWrapper(int sampleRate, int channels)
        : targetSampleRate(static_cast<drmp3_uint32>(sampleRate)), 
          targetChannels(static_cast<drmp3_uint32>(channels)), 
          isInitialized(false),
          currentFrameSize(0),
          minRequiredBytes(2048),
          isVBR(false),
          hasDecodedFrames(false),
          hasDecodedFrames(false)
    {
        previousFrameSizes.resize(10, 0);
        printf("MP3DecoderWrapper initialized with sampleRate=%d, channels=%d\n", sampleRate, channels);
    }

    ~MP3DecoderWrapper() {
        cleanup();
    }

    void cleanup() {
        if (isInitialized) {
            drmp3_uninit(&decoder);
            isInitialized = false;
        }
        std::fill(previousFrameSizes.begin(), previousFrameSizes.end(), 0);
        currentFrameSize = 0;
        minRequiredBytes = 2048;
        hasDecodedFrames = false;
    }

    size_t getMinimumBytesNeeded() const {
        return minRequiredBytes;
    }

    bool isVariableBitrate() const {
        return isVBR;
    }

    std::vector<float> decode(const unsigned char* inputData, size_t inputSize) {
        std::vector<float> decodedData;
        
        if (!inputData || inputSize < 4) return decodedData;

        // First time or reinitialization
        if (!isInitialized) {
            try {
                if (!initializeDecoder(inputData, inputSize)) {
                    printf("Failed to initialize decoder\n");
                    return decodedData;
                }
            } catch (const std::exception& e) {
                printf("Decoder initialization error: %s\n", e.what());
                return decodedData;
            }
        }

        // Pre-allocate buffer for efficiency
        std::vector<float> tempBuffer(2304);  // 1152 samples * 2 channels
        size_t totalBytesProcessed = 0;

        while (totalBytesProcessed + 4 <= inputSize) {
            drmp3dec_frame_info info = {};
            float* output = tempBuffer.data();
            
            // Try to decode a frame
            int samplesPerChannel = drmp3dec_decode_frame(
                &decoder.decoder,
                inputData + totalBytesProcessed,
                inputSize - totalBytesProcessed,
                output,
                &info
            );

            if (samplesPerChannel > 0) {
                size_t totalSamples = samplesPerChannel * info.channels;
                decodedData.insert(decodedData.end(), 
                                 output,
                                 output + totalSamples);

                updateFrameSizeTracking(info.frame_bytes);
                totalBytesProcessed += info.frame_bytes;
                hasDecodedFrames = true;
            } else {
                // Only try to find a new sync point if we haven't decoded any frames yet
                if (!hasDecodedFrames) {
                    size_t frameSize;
                    const unsigned char* next = inputData + totalBytesProcessed + 1;
                    size_t remaining = inputSize - totalBytesProcessed - 1;

                    while (remaining >= 4) {
                        if (isValidMp3Header(next, &frameSize)) {
                            printf("Found new valid sync point\n");
                            cleanup();
                            if (initializeDecoder(next, remaining)) {
                                totalBytesProcessed = next - inputData;
                                break;
                            }
                        }
                        next++;
                        remaining--;
                    }
                }
                totalBytesProcessed++;
            }
        }

        return decodedData;
    }

private:
    bool initializeDecoder(const unsigned char* data, size_t dataSize) {
        cleanup();

        if (dataSize < 4) {
            printf("Not enough data for MP3 header (%zu bytes)\n", dataSize);
            return false;
        }

        // Find sync word
        const unsigned char* syncPos = data;
        size_t remaining = dataSize;
        bool foundSync = false;
        
        while (remaining >= 4) {
            if ((syncPos[0] == 0xFF) && ((syncPos[1] & 0xE0) == 0xE0)) {
                // Verify MP3 header
                unsigned char version = (syncPos[1] >> 3) & 0x03;
                unsigned char layer = (syncPos[1] >> 1) & 0x03;
                unsigned char bitrate = (syncPos[2] >> 4) & 0x0F;
                unsigned char sampleRate = (syncPos[2] >> 2) & 0x03;
                unsigned char padding = (syncPos[2] >> 1) & 0x01;
                
                // More thorough validation of the header
                if (layer != 0 && bitrate != 0x0F && sampleRate != 0x03) {
                    // Calculate expected frame size to verify it's a valid frame
                    int samplingRates[] = {44100, 48000, 32000};  // MPEG-1
                    if (version == 2 || version == 0) {  // MPEG-2 or 2.5
                        for (int i = 0; i < 3; i++) samplingRates[i] /= 2;
                    }
                    
                    int sr = samplingRates[sampleRate];
                    int bitrateTable[] = {32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320};
                    int br = bitrateTable[bitrate - 1] * 1000;
                    
                    // Rough frame size calculation
                    int frameSize = (144 * br / sr) + padding;
                    
                    if (frameSize > 0 && frameSize <= 2048) {  // Reasonable frame size
                        foundSync = true;
                        break;
                    }
                }
            }
            syncPos++;
            remaining--;

        if (!foundSync) {
            printf("No valid MP3 header found in %zu bytes\n", dataSize);
            return false;
        }

        size_t offset = syncPos - data;
        printf("Found MP3 sync at offset %zu. Header: %02X %02X %02X %02X\n",
               offset, syncPos[0], syncPos[1], syncPos[2], syncPos[3]);

        // Initialize decoder
        drmp3_bool32 result = drmp3_init_memory(&decoder, syncPos, remaining, nullptr);
        if (!result) {
            printf("drmp3_init_memory failed\n");
            return false;
        }

        printf("Decoder initialized: sr=%u, ch=%u\n", decoder.sampleRate, decoder.channels);
        
        if (decoder.channels > 2) {
            cleanup();
            printf("Unsupported channel count: %u\n", decoder.channels);
            return false;
        }

        isInitialized = true;
        currentFrameSize = 0;  // Will be set after first successful decode
        return true;
    }

    void updateFrameSizeTracking(size_t newFrameSize) {
        if (newFrameSize == 0) return;

        if (currentFrameSize == 0) {
            currentFrameSize = newFrameSize;
            minRequiredBytes = newFrameSize;
            std::fill(previousFrameSizes.begin(), previousFrameSizes.end(), newFrameSize);
            return;
        }
        
        // Update frame size history
        previousFrameSizes.pop_front();
        previousFrameSizes.push_back(newFrameSize);

        // Check for VBR
        size_t firstSize = previousFrameSizes.front();
        isVBR = false;
        for (size_t size : previousFrameSizes) {
            if (size != firstSize) {
                isVBR = true;
                break;
            }
        }

        // Update minimum required bytes
        if (isVBR) {
            size_t maxSize = 0;
            for (size_t size : previousFrameSizes) {
                maxSize = std::max(maxSize, size);
            }
            minRequiredBytes = maxSize;
        } else {
            minRequiredBytes = newFrameSize;
        }
        
        currentFrameSize = newFrameSize;
    }

private:
    drmp3 decoder;
    drmp3_uint32 targetSampleRate;
    drmp3_uint32 targetChannels;
    bool isInitialized;
    size_t currentFrameSize;
    size_t minRequiredBytes;
    bool isVBR;
    std::deque<size_t> previousFrameSizes;
};

#endif // MP3_STREAM_DECODER_H
